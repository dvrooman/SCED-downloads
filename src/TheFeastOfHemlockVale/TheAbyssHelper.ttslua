-- TODO: - [ ] button to bring out "regular" abyss
--       - [ ] this would be a lot easier for the players to use with draw thingies next to each playermat. 

local deckLib              = require("util/DeckLib")
local guidReferenceApi     = require("core/GUIDReferenceApi")
local playermatApi         = require("playermat/PlayermatApi")
local searchLib            = require("util/SearchLib")

local colliding            = false
local helpVisibleToPlayers = {}
local setupVisible         = true

-- forward declaration of variables that are used across functions
local matColor, handColor, drawDeckPosition, topCardDetected

---------------------------------------------------------
-- MARK: main functionality
---------------------------------------------------------

function onLoad()
  self.max_typed_number = 99
end

-- set up discard area
function onCollisionEnter(collisionInfo)
  -- flag to catch multiple calls
  if colliding then return end
  colliding = true
  Wait.time(function() colliding = false end, 0.1)

  local obj = collisionInfo.collision_object

  -- exit early if nothing found or not a card/deck
  if obj.type ~= "Card" and obj.type ~= "Deck" then return end

  -- check if colliding obj is above
  if obj.getPosition().y < self.getPosition().y then return end

  -- make sure cards are face-up
  obj.setRotation(self.getRotation():setAt("z", 0))

  -- place objects into deck
  local bag = getAbyssBag()
  if not bag then return end

  -- make sure they get added to the top
  obj.setPosition(bag.getPosition() + Vector(0, 1, 0))
  if obj.type == "Card" then
    bag.putObject(obj)
  else
    obj.shuffle()
    for i = 1, #obj.getObjects() do
      bag.putObject(obj.takeObject())
    end
  end
end

-- click button to draw single card
function onXMLclick(player, number)
  matColor = playermatApi.getPlayerColor(player)
  startDraw(number)
end

-- type number to draw multiple cards
function onNumberTyped(player, number)
  matColor = playermatApi.getPlayerColor(player)
  if number > 0 then
    startDraw(number)
  end
end

---------------------------------------------------------
-- MARK: new "fancy" draw
---------------------------------------------------------

-- draw cards to dummy hand
function startDraw(number)
  if ongoingSearch then return end

  local bag = getAbyssBag()
  if not bag then return end

  local bagCount = #bag.getObjects()
  if bagCount == 0 then
    printToColor("The Abyss deck is empty!", matColor, matColor)
    return
  end

  -- intentionally global
  handColor = matColor

  topCardDetected = false

  -- get bounds to know the height of the deck
  local bounds = bag.getBounds()
  drawDeckPosition = bounds.center + Vector(0, bounds.size.y / 2 + 0.2, 0)

  local handData = Player[handColor].getHandTransform()

  -- create an additional hand zone
  local handZone = guidReferenceApi.getObjectByOwnerAndType(matColor, "HandZone")
  local data = handZone.getData()
  handCount = Player[handColor].getHandCount() + 1
  handZoneName = "HandZone2"
  local position = handZone.getPosition() + handData.forward * 7.5

  data.Transform.scaleZ = data.Transform.scaleZ * 0.6

  local newHand = spawnObjectData({ data = data, position = position })
  guidReferenceApi.editIndex(matColor, handZoneName, newHand.getGUID())

  -- add XML labels
  newHand.UI.setXmlTable({
    {
      tag = "Panel",
      attributes = {
        height = 120,
        width = 1500,
        scale = ".025 .167 1",
        position = "0 64 30",
      },
      children = {
        {
          tag = "TableLayout",
          attributes = { cellSpacing = "250" },
          children = {
            {
              tag = "Row",
              children = {
                {
                  tag = "Cell",
                  children = {
                    {
                      tag = "Panel",
                      attributes = { color = "#b6e2f099" },
                      children = {
                        {
                          tag = "Text",
                          attributes = { font = "font_teutonic-arkham", fontSize = "100" },
                          value = "draw more"
                        }
                      }
                    }
                  }
                },
                {
                  tag = "Cell",
                  children = {
                    {
                      tag = "Panel",
                      attributes = { color = "#b6e2f099" },
                      children = {
                        {
                          tag = "Text",
                          attributes = { font = "font_teutonic-arkham", fontSize = "100" },
                          value = "placeholder"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      tag = "Panel",
      attributes = {
        height = 170,
        width = 1500,
        scale = ".025 .167 1",
        position = "0 -67 30",
      },
      children = {
        {
          tag = "TableLayout",
          attributes = { cellSpacing = "250", cellBackgroundColor = "#b6e2f0" },
          children = {
            {
              tag = "Row",
              children = {
                {
                  tag = "Cell",
                  children = {
                    {
                      tag = "Panel",
                      attributes = { color = "#b6e2f0D9" },
                      children = {
                        {
                          tag = "Button",
                          attributes = {
                            color = "#ffffff00",
                            fontSize = "150",
                            onClick = self.getGUID() .. "/endSearch(false)",
                            tooltip = "Shuffle cards and Return to Abyss",
                            font = "font_teutonic-arkham",
                            textColors = "#000000|#009acb|#005a77"
                          },
                          value = "Return"
                        }
                      }
                    }
                  }
                },
                {
                  tag = "Cell",
                  children = {
                    {
                      tag = "Panel",
                      -- attributes = { color = "#b6e2f0D9" },
                      attributes = { color = "#700000D9" },
                      children = {
                        {
                          tag = "Button",
                          attributes = {
                            color = "#00000000",
                            fontSize = "150",
                            onClick = self.getGUID() .. "/endSearch(true)",
                            tooltip = "Remove cards from game",
                            font = "font_teutonic-arkham",
                            textColors = "#ffffff|#FFB0B0|#F24545"
                          },
                          value = "Remove"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  })

  searchView()

  -- location for temporary cards
  local bounds = bag.getBoundsNormalized()
  local pos = bounds.center
  pos.y = pos.y + bounds.size.y + 1

  local drawnCards = {} -- keeping track of drawn cards
  for i = 1, math.min(number, bagCount) do
    local takenObject = bag.takeObject({
      -- top = false, --only works on decks, not bags
      smooth = false,
      position = pos,
      index = 0, --last card in bag
    })
    table.insert(drawnCards, figureSortOrder(takenObject))
  end

  -- sort the drawn cards
  table.sort(
    drawnCards, function(a,b)
      return a.order < b.order
    end
  )
  
  -- deal to temporary hand
  Wait.frames(function() 
    for _, obj in ipairs(drawnCards) do
        obj.card.deal(1, handColor, handCount)
    end
  end, 3 + (topCardDetected and 30 or 0))
  
  -- make sure mythos/location cards aren't revealed
  Wait.frames(function() faceDownHand() end, 30)
end

-- put drawn cards back in abyss/remove from game
-- #TODO: changing shuffle to remove
function endSearch(_, shuffle) 
  local handToCheck = math.min(Player[handColor].getHandCount(), handCount)
  local handCards = Player[handColor].getHandObjects(handToCheck)

  -- place cards on deck
  deckLib.placeOrMergeIntoDeck(handCards, drawDeckPosition, self.getRotation():setAt("z", 180))

  local additionalHand = guidReferenceApi.getObjectByOwnerAndType(matColor, handZoneName)
  if additionalHand then
    Wait.time(function() additionalHand.destruct() end, 0.5 + #handCards * 0.1)
    guidReferenceApi.editIndex(matColor, handZoneName, nil)
  end

  normalView()

  Wait.time(function()
    -- maybe shuffle deck
    if shuffle == "true" then
      local deckAreaObjects
      if owner == "Mythos" then
        deckAreaObjects = mythosAreaApi.getEncounterDeckObjects()
      else
        deckAreaObjects = playermatApi.getDeckAreaObjects(matColor)
      end

      if deckAreaObjects.draw then
        deckAreaObjects.draw.shuffle()
      end
    end

    -- Norman Withers / Eye of Ghatanothoa handling
    if topCardDetected then
      if owner == "Mythos" then
        mythosAreaApi.flipTopCardFromDeck()
      else
        playermatApi.flipTopCardFromDeck(matColor)
      end
    end
  end, 1 + #handCards * 0.1)
end

---------------------------------------------------------
-- MARK: XML click functions
---------------------------------------------------------

-- draws a card to the playmat of the requesting player
function drawFromAbyssORIG(player, number)
  local bag = getAbyssBag()
  if not bag then return end

  local bagCount = #bag.getObjects()
  if bagCount == 0 then
    printToColor("The Abyss deck is empty!", player.color)
    return
  end

  local matColor = playermatApi.getMatColor(player.color)
  local pos = playermatApi.getEncounterCardDrawPosition(matColor, false)
  local rot = playermatApi.returnRotation(matColor)

  for i = 1, math.min(number, bagCount) do
    deckLib.placeOrMergeIntoDeck(bag.takeObject({ index = 0 }), Vector(pos), rot)
  end
end

---------------------------------------------------------
-- MARK: helper functions
---------------------------------------------------------

-- called from the onNumberTyped of the Abyss Bag
function drawFromAbyssWrapper(params)
  -- drawFromAbyss(Player[params.playerColor], params.number)
  matColor = playermatApi.getPlayerColor(params.playerColor)
  startDraw(params.number)
end

-- returns a reference to the abyss deck
function getAbyssBag()
  for _, obj in ipairs(searchLib.atPosition(self.positionToWorld({ x = 1.05, y = 0.05, z = 0.16 }))) do
    if obj.type == "Bag" then
      return obj
    end
  end

  printToAll("Couldn't find Abyss deck!", "Orange")
  return nil
end

-- returns a reference to one of the abyss setup decks
---@param topOrBottom string return top|bottom bag
function getSetupBag(topOrBottom)
  local offset = { x = -1, y = 0, z = 3 } --top
  if topOrBottom == "bottom" then offset.z = 4.12 end

  local bag
  for _, obj in ipairs(searchLib.atPosition(self.positionToWorld(offset))) do
    if obj.type == "Bag" then
      bag = obj
      break
    end
  end

  if not bag then
    printToAll("Couldn't find " .. topOrBottom .. " setup deck!", "Orange")
    return
  end

  return bag
end

---------------------------------------------------------
-- MARK: setup functions
---------------------------------------------------------

-- adds a tag to all cards of each player
function tagPlayerCards()
  local count = 0
  for matColor, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
    for _, obj in ipairs(playermatApi.searchAroundPlayermat(matColor)) do
      local tagString = "_" .. matColor
      if obj.type == "Card" then
        obj.addTag(tagString)
        count = count + 1
      elseif obj.type == "Deck" or obj.type == "Bag" then
        local data = obj.getData()
        for _, cardData in ipairs(data.ContainedObjects or {}) do
          cardData.Tags = cardData.Tags or {}
          table.insert(cardData.Tags, tagString)
          count = count + 1
        end
        obj.destruct()
        spawnObjectData({ data = data })
      end
    end
  end

  if count > 0 then
    printToAll("Tagged " .. count .. " cards with playermat color!", "Green")
  else
    printToAll("No cards found to tag!", "Orange")
  end

  -- update setup section
  self.UI.setAttribute("tagRow", "active", false)
  self.UI.setAttribute("splitRow", "active", true)
  enableNavigation()
end

function splitAbyss()
  local bag = getAbyssBag()
  local bottomBag = getSetupBag("bottom")
  local topBag = getSetupBag("top")

  local bagCount = #bag.getObjects()
  local half = math.floor(bagCount / 2)

  bag.shuffle()

  bottomBag.call("setReadOnly", false)
  for i = 1, bagCount do
    if i <= half then
      bottomBag.putObject(bag.takeObject())
    else
      topBag.putObject(bag.takeObject())
    end
  end
  bottomBag.call("setReadOnly", true)

  self.UI.setAttribute("splitRow", "active", false)
  self.UI.setAttribute("finalizeRow", "active", true)
  enableNavigation()
end

function finalizeAbyss()
  local bag = getAbyssBag()
  if not bag then return end

  local bottomBag = getSetupBag("bottom")
  bottomBag.shuffle()
  for i = 1, #bottomBag.getObjects() do
    bag.putObject(bottomBag.takeObject())
  end

  local topBag = getSetupBag("top")
  topBag.shuffle()
  for i = 1, #topBag.getObjects() do
    bag.putObject(topBag.takeObject())
  end

  toggleSetup() -- hide the setup
end

---------------------------------------------------------
-- MARK: setup UI functions
---------------------------------------------------------

-- toggles the help text for the player that clicks it
function toggleHelp(player)
  if helpVisibleToPlayers[player.color] then
    helpVisibleToPlayers[player.color] = nil
  else
    helpVisibleToPlayers[player.color] = true
  end
  updateHelpVisibility()
end

-- toggles the setup section
function toggleSetup()
  local bottomBag = getSetupBag("bottom")
  local topBag = getSetupBag("top")

  setupVisible = not setupVisible
  self.UI.setAttribute("setupPanel", "active", setupVisible)

  if setupVisible then
    self.UI.setAttribute("showAbyssSetupButton", "text", "Hide Abyss Setup")
    bottomBag.setInvisibleTo({})
    topBag.setInvisibleTo({})
  else
    self.UI.setAttribute("showAbyssSetupButton", "text", "Show Abyss Setup")
    bottomBag.setInvisibleTo(Player.getColors())
    topBag.setInvisibleTo(Player.getColors())
  end
end

function previousStep()
  if self.UI.getAttribute("splitRow", "active") == "True" then
    self.UI.setAttribute("splitRow", "active", false)
    self.UI.setAttribute("tagRow", "active", true)
  elseif self.UI.getAttribute("finalizeRow", "active") == "True" then
    self.UI.setAttribute("finalizeRow", "active", false)
    self.UI.setAttribute("splitRow", "active", true)
  end

  enableNavigation()
end

function nextStep()
  if self.UI.getAttribute("tagRow", "active") == "True" then
    self.UI.setAttribute("tagRow", "active", false)
    self.UI.setAttribute("splitRow", "active", true)
  elseif self.UI.getAttribute("splitRow", "active") == "True" then
    self.UI.setAttribute("splitRow", "active", false)
    self.UI.setAttribute("finalizeRow", "active", true)
  end

  enableNavigation()
end

-- enable previous and next setup buttons
function enableNavigation()
  Wait.frames(function()
    local back = true
    if self.UI.getAttribute("tagRow", "active") == "True" then back = false end
    self.UI.setAttribute("backButton", "active", back)

    local forward = true
    if self.UI.getAttribute("finalizeRow", "active") == "True" then forward = false end
    self.UI.setAttribute("forwardButton", "active", forward)

    updateExplanation()
  end, 1)
end

function updateExplanation()
  local explanationText
  if self.UI.getAttribute("tagRow", "active") == "True" then
    explanationText = "Make sure all player decks are loaded, then click to tag all player cards with \n< AbyssMat<i>Color</i> >."
  elseif self.UI.getAttribute("splitRow", "active") == "True" then
    explanationText = "Click to shuffle Abyss & split into two halves."
  elseif self.UI.getAttribute("finalizeRow", "active") == "True" then
    explanationText = "Place player/Investigator cards in top bag.\n\nClick to shuffle top & place both halves back in Abyss."
  end

  self.UI.setValue("explanation", explanationText)
end

-- updates the visibility of the help text
function updateHelpVisibility()
  local visibility = ""
  for playerColor, _ in pairs(helpVisibleToPlayers) do
    if string.len(visibility) > 0 then
      visibility = visibility .. "|" .. playerColor
    else
      visibility = playerColor
    end
  end
  self.UI.setAttribute("helpText", "visibility", visibility)
  self.UI.setAttribute("helpPanel", "visibility", visibility)
  self.UI.setAttribute("helpPanel", "active", string.len(visibility) > 0)
end

---------------------------------------------------------
-- MARK: draw helper functions
---------------------------------------------------------

-- regular view with search box
function normalView()
  ongoingSearch = false
  -- self.clearButtons()

  -- -- create buttons to search 3, 6 or 9 cards
  -- for _, data in ipairs(buttonLabels) do
  --   quickParameters.click_function = "search" .. data.label
  --   quickParameters.label          = data.label
  --   quickParameters.position       = data.position
  --   self.createButton(quickParameters)
  -- end
end

-- view during a search with "done" buttons
function searchView()
  ongoingSearch = true
  -- self.clearButtons()
end

-- make sure mythos cards aren't revealed
-- locations should be unrevealed by defalt when dealt to a hand
function faceDownHand()
  for _, obj in ipairs(Player[matColor].getHandObjects(handCount)) do
    if not obj.hasTag("PlayerCard") and not obj.hasTag("Location") then
        local rot = obj.getRotation():setAt("z", 180)
        obj.setRotation(rot)
    end
  end
end

-- input card object: return table with card & sort order info
function figureSortOrder(obj)
  local groupOrder
  if obj.hasTag("Investigator") then
    groupOrder = 5
  elseif obj.hasTag("PlayerCard") then
    -- subsorting for player cards by player mat color
    if obj.hasTag("_Green") then
      groupOrder = 10
    elseif obj.hasTag("_White") then
      groupOrder = 11
    elseif obj.hasTag("_Orange") then
      groupOrder = 12
    elseif obj.hasTag("_Red") then
      groupOrder = 13
    else
      groupOrder = 14
    end
  elseif obj.hasTag("Location") then
    groupOrder = 20
  else
    groupOrder = 30
  end
  return {card=obj, order=groupOrder}
end
